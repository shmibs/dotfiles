################### ALIASES ##################
alias def='sdcv'
alias dvd='mpv --deinterlace=yes dvd://'
alias hc='herbstclient'
alias ssh-socks='ssh -C2qTnN -D 9853 shmibbles.me'
alias svim='sudo -E vim'
alias svimdiff='sudo -E vimdiff'
alias thesaurus='aiksaurus'
alias vmount='udevil mount'
alias vumount='udevil umount'
alias smounth='mkdir -p ~/shmibbles.me; sshfs shmibbles.me: ~/shmibbles.me'
alias smountw='mkdir -p ~/shmibbles.me; sshfs shmibbles.me:/usr/local/www/apache24/data/ ~/shmibbles.me'
alias sumount='fusermount -u ~/shmibbles.me; rmdir ~/shmibbles.me'

################## FUNCTIONS ##################

# list stats about mpd library file types, to motivate me
# to do better!
mpd-filetypes() {
	local pattern

	# if args exist, read them as file extensions in a pattern
	if 
	if [[ ! -z "$@" ]]; then
		pattern=$(echo "$@" | sed -e 's/\s/|/g' -e 's/\(.*\)/(\1)/')
	else
	# else hackily yoink recognised types from mpd --version
		pattern=$(mpd --version \
			| sed -n '1h; 1!H; ${g; s/.*Decoders plugins:\(.*\)Output.*/\1/g; p}' \
			| sed -e 's/.*\]//' | tr -d '\n' \
			| sed -e 's/^ //' -e 's/\s/|/g' -e 's/\(.*\)/(\1)/')
	fi

	# find file counts
	local i=1
	local total=0
	local totalstr='total'
	local counts=()
	local types=()
	find ~/music -type f -regextype posix-extended \
		-regex ".*\.$pattern" | grep -oE "\.$pattern$" \
		| sort | uniq -c | sed -e 's/^\s*\([0-9]* \)\./\1/' | \
	while read -A line; do
		counts[$i]=${line[1]}
		types[$i]=${line[2]}
		total=$(( $total + ${line[1]} ))
		i=$(( $i + 1 ))
	done

	# calculate percentages
	local twidth=0
	local cwidth=0
	local percentages=()
	for i in {1..${#types}}; do
		percentages[$i]="%$(calc -p \
			"a=${counts[$i]} * 100 / $total; round(a, 5-digits(a), 16)" \
			| tr -d '~')"

	done

	types=( 'type' "${types[@]}" 'total' )
	counts=( 'count' "${counts[@]}" $total )
	percentages=( 'percent' "${percentages[@]}" '       ')

	# calculate padding widths
	for i in {1..${#types}}; do
		if [[ ${#types[$i]} -gt $twidth ]]; then
			twidth=${#types[$i]}
		fi

		if [[ ${#counts[$i]} -gt $cwidth ]]; then
			cwidth=${#counts[$i]}
		fi
	done


	# print results
	local linelen=$(( $twidth + $cwidth + 13 ))
	local j
	echo -n "┌"
	for (( j=0; j < $linelen; j++ )); do
		echo -n "─"
	done
	echo "┐"

	for i in {1..${#types}}; do
		if [[ $i -eq 2 || $i -eq ${#types} ]]; then
			echo -n "├"
			for (( j=0; j < $linelen; j++ )); do
				echo -n "─"
			done
			echo "┤"
		fi

		if [[ $i -eq 1 ]]; then
			printf "│ %${twidth}s  " "${types[$i]}"
		else
			printf "│ %${twidth}s: " "${types[$i]}"
		fi

		printf "%${cwidth}s" "${counts[$i]}"

		if [[ $i -eq 1 || $i -eq ${#types} ]]; then
			printf "  %-7s │\n" "${percentages[$i]}"
		else
			printf ", %-7s │\n" "${percentages[$i]}"
		fi
	done

	echo -n "└"
	for (( j=0; j < $linelen; j++ )); do
		echo -n "─"
	done
	echo "┘"
}

# take a screenshot, upload to /img/scrot, and update current symlink
ssh-scrot() {
	archey3

	local name
	if [[ "$1" != "" ]]; then
		name=$1
	else
		echo -n "name: "
		read name
	fi
	
	local date=$(date +'%Y-%m-%d')
	
	local folder="http/img/scrot"
	ssh shmibbles.me "mkdir -p $folder/$date"
	
	if [[ "${?#0}" != "" ]]; then
		return 1
	fi

	ssh shmibbles.me "cd $folder; rm current 2>/dev/null; ln -s $date current"
	
	for i in {3..1}; do
		echo -n "$i "
		sleep 1
	done
	
	echo 'cheese!'
	sleep .1

	scrot /tmp/$name.png
	convert -scale 250x /tmp/$name.png /tmp/${name}_small.png

	scp /tmp/$name.png /tmp/${name}_small.png shmibbles.me:http/img/scrot/$date

	echo "https://shmibbles.me/img/scrot/$date/$name.png" | tr -d '\n' | xclip -i -selection clipboard
	echo "https://shmibbles.me/img/scrot/$date/$name.png" | tr -d '\n' | xclip -i -selection primary
	echo "https://shmibbles.me/img/scrot/$date/${name}_small.png" | tr -d '\n' | xclip -i -selection clipboard
	echo "https://shmibbles.me/img/scrot/$date/${name}_small.png" | tr -d '\n' | xclip -i -selection primary

	echo 'sent!'

	rm /tmp/$name.png /tmp/${name}_small.png

}

make-gif-old() {

	if [[ -z "$1" ]]; then
		break
	fi

	rm -f make-gif-palette.png
	rm -f make-gif-palette.png
	rm -f make-gif-in
	
	rm -f make-gif-in
	
	ln -s "$1" make-gif-in
	
	local start
	echo -n "start [00:00:00]: "
	read start
	if [[ -z "$start" ]]; then
		start="00:00:00"
	fi
	
	local length
	echo -n "length [full]: "
	read length
	if [[ -z "$length" ]]; then
		t=""
		length=""
	else
		t="-t"
	fi

	local fps
	echo -n "fps [10]: "
	read fps
	if [[ -z "$fps" ]]; then
		fps="10"
	fi
	
	local width
	echo -n "width [480]: "
	read width
	if [[ -z "$width" ]]; then
		width="480"
	fi

	local subs
	echo -n "use subtitles? [y/N]: "
	read subs
	if [[ "$subs" == "y" || "$subs" == "Y" ]]; then
		subs="true"
	else 
		subs=""
	fi
	
	if [[ $subs ]]; then
		ffmpeg -y -ss "$start" $t "$length" -i "$1" \
			-copyts -vf "subtitles=make-gif-in,fps=$fps,scale=$width:-1:flags=lanczos,palettegen" make-gif-palette.png
		ffmpeg -ss "$start" $t "$length" -i "$1" -i make-gif-palette.png \
			-copyts -filter_complex \
			"subtitles=make-gif-in,fps=$fps,scale=$width:-1:flags=lanczos[x];[x][1:v]paletteuse" \
			out.gif
	else
		ffmpeg -y -ss "$start" $t "$length" -i "$1" \
			-vf "fps=$fps,scale=$width:-1:flags=lanczos,palettegen" make-gif-palette.png
		ffmpeg -ss "$start" $t "$length" -i "$1" -i make-gif-palette.png -filter_complex \
			"fps=$fps,scale=$width:-1:flags=lanczos[x];[x][1:v]paletteuse" \
			out.gif
	fi

	rm -f make-gif-palette.png
	rm -f make-gif-in
}

# export a section of a video to gif
make-gif() {

	local i

	local infile=""
	local outfile="out.gif"
	local start="00:00:00"
	local t=""
	local length=""
	local fps="10"
	typeset -i fps
	local width="480"
	typeset -i width
	local subs="n"

	# parse args
	local assign=false
	local assignopt=""
	local interact=true
	for i in "$@"; do
		if [[ $assign ]]; then
			assign=false
			case $assignopt in
				# output
				-o)	outfile="$i" ;;
				# start
				-s)	start="$i" ;;
				# length
				-l)	t="-t"; length="$i"	;;
				# fps
				-f) fps="$i" ;;
				# width
				-w) width="$i" ;;
				# subs?
				-t) subs="y" ;;
				*)
					>&2 echo "err: unrecognised option"
					return
					;;
			esac
		else
			case $i in
				-*)
					assign=true
					assignopt="$i"
					interact=false
					;;
				*)
					if [[ -z "$infile" ]]; then
						infile="$i"
					else
						>&2 echo "err: multiple inputs specified"
						return
					fi
					;;
			esac
		fi
	done

	if [[ $assign ]]; then
		>&2 echo "err: malformed arg"
		return
	fi

	if [[ -z "$infile" ]]; then
		>&2 echo "err: no input specified"
		return
	fi
	
	# interactive prompting
	if [[ $interact ]]; then
		read "i?start [00:00:00]: "
		if [[ "$i" ]]; then
			start="$i"
		fi
		
		read "i?length [full]: "
		if [[ "$i" ]]; then
			t="-t"
			length="$i"
		fi

		read "i?fps [10]: "
		if [[ "$i" ]]; then
			fps="$i"
		fi
		
		read "i?width [480]: "
		if [[ "$i" ]]; then
			width="$i"
		fi

		read -q "subs?use subtitles? [y/N]: "
		>&2 echo -e "\n"

		read "i?write to: "
		if [[ "$i" ]]; then
			outfile="$i"
		fi
	fi

	rm -f make-gif-palette.png
	rm -f make-gif-palette.png
	rm -f make-gif-in
	
	ln -s "$infile" make-gif-in

	>&2 echo "converting..."
	
	if [[ "$subs" == "y" ]]; then
		ffmpeg -loglevel 0 -y -ss "$start" $t "$length" -i "$infile" \
			-copyts -vf "subtitles=make-gif-in,fps=$fps,scale=$width:-1:flags=lanczos,palettegen" make-gif-palette.png
		ffmpeg -loglevel 0 -ss "$start" $t "$length" -i "$infile" -i make-gif-palette.png \
			-copyts -filter_complex \
			"subtitles=make-gif-in,fps=$fps,scale=$width:-1:flags=lanczos[x];[x][1:v]paletteuse" \
			make-gif-out
	else
		ffmpeg -loglevel 0 -y -ss "$start" $t "$length" -i "$infile" \
			-vf "fps=$fps,scale=$width:-1:flags=lanczos,palettegen" make-gif-palette.png
		ffmpeg -loglevel 0 -ss "$start" $t "$length" -i "$infile" -i make-gif-palette.png -filter_complex \
			"fps=$fps,scale=$width:-1:flags=lanczos[x];[x][1:v]paletteuse" \
			make-gif-out
	fi

	>&2 echo "optimising..."

	rm -f make-gif-palette.png
	rm -f make-gif-in

	gifsicle -O3 -o "$outfile" make-gif-out

	rm -f make-gif-out

	>&2 echo "done!"
}

# um...
fuck() {
	local fuck="fuck"
	while true; do
		echo -en "\e[$((RANDOM%2));$((RANDOM%8+30))m"

		for i in {1..${#fuck}}; do
			if [[ $((RANDOM%2)) -eq 1 ]]; then
				echo -n $fuck[$i] | tr '[:lower:]' '[:upper:]'
			else
				echo -n $fuck[$i]
			fi
		done

		for i in {1..$((RANDOM%20))}; do
			echo -n " "
		done
	done
}
